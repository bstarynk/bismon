% file conclus-bm.tex, which is \input from bismon-doc.tex
\section{Conclusion}
\label{sec:conclusion}

The \texttt{bismon} free software is developed in an agile and
incremental manner~\footnote{So there are no released stable versions
  of this software, but snapshots.} (required by its bootstrapping
approach), with continuous updates to
\bmurl{https://github.com/bstarynk/bismon/}.

In october 2018, the persistence machinery is working and daily used
to enhance \texttt{bismon}. The agenda mechanism is working. A naive
stop-the-world mark-and-sweep precise garbage collector is
implemented. The generation of internal C code is done (by
hand-written routines, still coded in C), this enables the
meta-programming approach. The web interface is worked upon: a
\texttt{libonion} based infrastructure is already handling HTTP
requests, and a GDPR-compliant login form is presented on web
browsers. Our \texttt{jsweb\_module} contains the functions related to
Javascript (nearly complete) and HTML generation (work in progress). The
syntactical editor (replacing the crude GTK interface) and then the
GCC plugin generation should be worked on.

In august 2019, the web machinery is mostly working. More generated C
code is available. The JSON handling is incomplete. Bismon
continuations \index{contination!reification} \index{reification!of
  continuations} are almost\footnote{Thanks to generated invocations of
  the \texttt{LOCALFRAME\_BM}
  \index{LOCALFRAME\_BM@\texttt{LOCALFRAME\_BM}} \emph{C} macro, which
  provides 90\% of the development work: full transient reification of
  partial continuations, that is of \index{call stack} \index{call
    frame} call stack segments, is just a matter of clustering emitted
  stack-local \index{stackframe\_stBM@\texttt{stackframe\_stBM}}
  \texttt{struct stackframe\_stBM}-based linked-lists of Bismon call
  frames.}  reifiable into transient \index{transient!object for
  continuations} objects, having as payload a linked-list sequence of
\index{call frame} call frames.

The final D1.3~\textsuperscript{v2} version (scheduled for M30) of
this deliverable will explain the Web interfaces (both for the
ordinary user, i.e. the IoT developer; and for the static analysis
expert) and the generation of C++ code for GCC plugins, with some
examples of simple, IoT focused, whole-program static source code
analysis performed by \emph{bismon}. So the final
D1.3~\textsuperscript{v2} document will contain a longer conclusion.

Within the timeframe allocated for \textsc{Chariot} it was not
realistically possible in May 2020 to partly or fully generate
\href{https://gcc.gnu.org/onlinedocs/gccint/Plugins.html}{GCC plugins}
C++ code (like past
\href{http://starynkevitch.net/Basile/gcc-melt/}{GCC MELT} did), in
particular because \textsc{Bismon} has no usable documentation, and
understanding its persistent heap of 3485 objects is not realistic
without such a documentation. A garbage collection
\cite{Jones:2016:GC-handbook} design bug (and its subtle interaction
with the powerful but complex \href{https://www.gtk.org/}{GTK}
graphical toolkit) makes the current \textsc{Bismon} (of git
\href{https://github.com/bstarynk/bismon/commit/cb1c4ccfe3802fa330d48fc97c2913943736ba2f}{id
  \texttt{cb1c4ccfe3802fa33}}....) extremely brittle, to the point of
being barely usable. The original insight was to generate most parts
of such \emph{Bismon} documentation, per the
\href{https://en.wikipedia.org/wiki/Unix_philosophy}{Unix philosophy}
and decade of related practice (from the original
\href{https://www.troff.org/}{\texttt{troff}} to prior practice in
\href{http://starynkevitch.net/Basile/gcc-melt/}{GCC MELT}, or to
\href{https://www.doxygen.nl/}{\textsc{Doxygen}} or
\href{http://ocaml.org/}{\textsc{Ocaml}} ...) but such a
documentation, even if it is quite reasonably easy to generate from an
orthogonally persistent
\href{https://en.wikipedia.org/wiki/Semantic_network}{semantic
  network} such as \textsc{Bismon}'s heap, would largely overflow the
70 pages hard limit (\textsc{Chariot} consortium defined) of this
report: notice that the generated
\href{http://starynkevitch.net/Basile/gcc-melt/}{GCC MELT} \index{GCC
  MELT@\textsc{Gcc Melt}} past documentation had hundreds of A4
pages....

Machine learning techniques inspired by \cite{zhang:2019:learned}
could be relevant in \textsc{Bismon}. See also the
\href{http://refpersys.org/}{\textsc{RefPerSys}} \index{RefPerSys
  project@\textsc{RefPerSys} project} research\footnote{Also related:
  \href{https://afia.asso.fr/journee-hommage-j-pitrat/}{talks in the
    memory of J.Pitrat, AFIA, March 6\textsuperscript{th}, 2020,
    Paris.}} project, inspired by \cite{Pitrat:1996:FGCS,
  Pitrat:2009:AST, Pitrat:2009:ArtifBeings, Starynkevitch-1990-EUM,
  Bordini:2020:agent}. The \index{machine learning} \index{topological
  data analysis} \index{deeplearning4j@\textsc{DeepLearning4J}
  framework}
\href{https://deeplearning4j.org/}{\texttt{deeplearning4j.org}}
infrastructure (used as a web service), or opensource C++ machine
learning libraries such as \index{mlpack@\textsc{MlPack} machine
  learning framework} \index{gudhi@\textsc{Gudhi} topological data
  analysis framework} \href{https://mlpack.org}{\texttt{mlpack.org}}
or \href{https://www.tensorflow.org/}{\textsc{TensorFlow} machine
  learning}, or \index{ttk@\textsc{Ttk} topological data analysis
  toolkit} topological data analysis libraries such as
\href{https://gudhi.inria.fr/}{\textsc{Gudhi}} (see
\cite{gudhi:2020:urm, gudhi:2020:PersistentCohomology,
  gudhi:2020:RipsComplex}) or
\href{https://topology-tool-kit.github.io/}{\textsc{Ttk}} (see
\cite{Masood:2019:ttk}) be coupled to \textsc{Bismon}. Such future
work would however require further funding for at least a year of
qualified developer work (see also
\cite{Maglogiannis:2007:emerging-ai-app} and
\index{ai4eu@\textsc{Ai4eu} project} the
\href{https://www.ai4eu.eu/}{\texttt{ai4eu.eu}} project, but don't
forget the empirical
\href{https://en.wikipedia.org/wiki/Hofstadter\%27s\_law}{Hofstadter's
  law}).

\medskip

