%% file datapersist-bm.tex, which is \input from bismon-doc.tex
\section{Data and its persistence in \emph{Bismon}}

\subsection{data processed in \emph{Bismon}}

The \emph{Bismon monitor} handles various kinds of
\index{data}{data}. A lot of data is \index{immutable}{immutable} (its
content cannot change once the data has been created, for example
strings). But \index{object}{\textbf{objects}} are of course mutable
and can be modified after creation. Since \emph{Bismon} is
multi-threaded and its agenda is running \emph{several} worker threads
in parallel, these mutable objects contain a \index{mutex}{mutex} for
locking purposes.

So the \emph{Bismon monitor} handle values: they can be immutable, or
objects (and objects are the only kind of mutable data).

\subsubsection{Immutable values}

They include

\begin{itemize}

\item \textbf{tagged integer} (of 63 bits). The \index{integer}{integer} won't change
  (and integer values don't require extra space to keep that integer).
  
\item UTF-8 encoded \textbf{string} (the bytes inside such
  \index{string}{strings} don't change).

  \item \textbf{tuple} of objects, that is an ordered (but immutable)
    sequence of object pointers (the size or content of a tuple don't
    change). A given object could appear in several positions in a
    \index{tuple}{tuple}.

    \item \textbf{set} of objects, organized internally as a sorted
      array of object pointers. A given object can occur only once in
      a set, and membership (of an object inside a set) is tested
      dichotomically in logarithmic time. Of course, the size and
      content of a \index{set}{set} don't change with time.

      \item \textbf{node}. A \index{node}{node} has an object
        connective, and a (possibly empty, but fixed) sequence of
        \index{son}{sons} (sons are themselves values, so can
        themselves be integers, strings, tuples, sets, sub-nodes). The
        connective, size and sons of a node don't change with
        time. Since a node is immutable and knows all its sons at
        creation time, circularity (e.g. a node having itself as some
        grand-son) inside it is impossible, and the node has a finite
        depth.
        
\end{itemize}

The \index{nil}{\textbf{nil}} value is generally not considered as a
value, but as the absence of some value. We might (later) add other
kind of values (perhaps vectors of integers, of doubles, bignums ...),
but they should all be immutable. It is likely that we prefer complex
or weird data to sit inside objects.

Tuples and nodes could contain nil, but sets cannot. A node connective
is a genuine object (so cannot be nil), but a node could have nil
sons.

Sets and tuples are sometimes both considered as
\index{sequence}{\textbf{sequences}} and share some common operations.

The immutable values are somehow lightweight. Most of them (strings,
sets, tuples, nodes) internally keep some hash-code (e.g. to
accelerate equality tests on them, or accessing hash tables having
values as keys). The memory overhead for values is therefore small (a
few extra words at most, to keep GC-data type and mark, size hash).

The size of values (byte length of strings, number of objects in
tuples or sets, number of sons in nodes) can in principle reach
$2^{31} - 1$ but is generally much smaller (often less than a few
dozens) and could be 0.

Mutable values outside of objects (and their payload, see below)
cannot exist.

Values (even references to objects, e.g. inside sequences or nodes)
are represented as a machine pointer and fit in a 64 bits word. When
its least significant bit is 1, it is a tagged integer.

Values, including objects, are comparable so sortable. For nodes,
sets, tuples we use a lexicographical order.

\subsubsection{Mutable objects}

\index{object}{Objects} are the only kind of \index{mutable}{mutable}
values, and are somehow heavy (at least severy dozens of machine words
in memory). They can be accessed nearly simultaneously by several
worker threads running different tasklets, so they need a locking
mechanism and contain a (recursive) mutex\footnote{Created with
  \href{http://man7.org/linux/man-pages/man3/pthread\_mutex\_lock.3p.html}{\texttt{pthread\_mutex\_lock}(3)}
  with \texttt{PTHREAD\_MUTEX\_RECURSIVE} attribute} (so in reality
only one thread is using them at a given instant).

\medskip

\emph{Conceptually}, objects contain the following data:

\begin{itemize}
  \item a constant \emph{unique} serial id (of about 128 bits), called
    the \index{objid}{\textbf{objid}}, randomly generated at object
    creation time and never changed after. In many occasions, that
    objid is printed as 24 characters (two glued blocks of 12
    characters, the first being an underscore \texttt{\_}, the second
    being a digit, the 10 others being alphanumerical with significant
    case) such as \texttt{\_4ggW2XwfXdp\_1XRSvOvZqTC}~\footnote{That
      objid \texttt{\_4ggW2XwfXdp\_1XRSvOvZqTC} is for the predefined
      object \emph{\texttt{the\_system}}, and corresponds to the two
      64 bits numbers 3577488711679049683, 1649751471969277032 i.e. to
      128 bits hexadecimal 0x31a5cb0767997fd316e5183916681468} or
    \texttt{\_0xbmmxnN8E8\_0ZuEqJmqMNH}. It is expected that objid
    \index{collision}{collisions} never occur in practice, e.g. that
    even thousands of \emph{Bismon monitor} processes (running on many
    distant computers) would in fact never generate the same objid. In
    other words, our objids are as unique as \index{UUID}{UUID}s (from
    \href{https://tools.ietf.org/html/rfc4122}{RFC 4122}) are (but are
    displayed differently, without hyphens). The concrete textual
    ``syntax'' for objid-s is carefully chosen to be compatible and
    friendly with identifiers in C, C++, Java, Ocaml, etc. The
    \emph{Bismon} runtime maintains a large array of hashtables and
    mutexes to be able to quickly find the object pointer of a given
    objid (if such an object exists in memory). The objid is used to
    compare (and sort) objects. The (32 bits, non-zero) hash code of
    an object is obtained from its objid (but it is cached in the
    object's memory, for performance reasons).

    \item the recursive \textbf{mutex lock} of that object\footnote{We
      have considered using a pthread \texttt{rwlock} instead of a
      \texttt{mutex}, but that would probably be more heavy and
      perhaps slower, but could be experimented in the future.}. So
      locking (or unlocking) an object really means using that lock on
      pthread mutex operations~\footnote{So accessing without the
        protection of that lock being hold, any data inside an object,
        other than its constant objid, its class, its routine pointer,
        is forbidden and considered as \emph{undefined behavior}}.

  \item a \index{space}{\textbf{space}} number fitting in a single
    byte. The space 0 is for \index{transient}{\emph{transient}}
    objects that are not persisted to disk. The space 1 is for
    \index{predefined}{\emph{predefined}} objects (there are about 60
    of them in Q3 of 2018), which are conceptually created before the
    start of \emph{Bismon monitor} processes and are permanently
    available, even at initial load time of the persistent
    store. Those predefined objects are dumped in file
    \texttt{store1.bmon}, the objects of space 2 (conventionally
    called the \emph{global} space) are dumped and persisted in file
    \texttt{store2.bmon}, etc...

    \item the \index{mtime}{\textbf{mtime}} of an object holds its
      modification time, with a millisecond granularity, since the
      Unix Epoch. \index{touch}{Touching} an object is updating its
      \emph{mtime} to the current time.

    \item the (mutable!) \index{class}{\textbf{class}} of an object is
      an \index{atomic}{\emph{atomic}}~\footnote{``atomic'' in the C
        or C++ memory sense; so a pointer declared \texttt{\_Atomic}
        in C or \texttt{std::atomic} in C++, supposing that they are
        the same and interoperable.} pointer to an object (usually
      another one) describing its class, as understood by
      \emph{Bismon}. It is allowed to change
      dynamically~\footnote{Changing classes is permitted with
        reasonable bounds: the class of all classes should remain the
        \emph{\texttt{class}} predefined object, but of course such an
        invariant cannot be proved.} the class of any object. Classes
      describe the behavior (i.e. the dictionnary of ``methods''), not
      the content (i.e. the ``attributes'') of objects and enable
      single-inheritance (every class has one super-class).

    \item the \index{attribute}{\emph{attributes}} of an object are
      organized as an hash-table associating attribute or key objects
      to arbitrary non-nil values. An \textbf{attribute} is an
      arbitrary object, and its value is arbitrary (but cannot be
      nil).

    \item the \index{component}{\emph{components}} of an object are
      organized as a vector (whose size can change, grow, or shrink)
      of values. A \textbf{component} inside an object is a value
      (possibly nil).

      \item objects may contain one \textbf{routine} pointer (or nil),
        described by \begin{enumerate}
          
        \item the \index{routine address}{\emph{routine address}}
          inside an object is a function or \index{routine}{routine}
          pointer (in the C sense, possibly and often nil). The
          signature of that function is described by the routine
          signature~\footnote{Perhaps all our routines will keep the
            same signature, and then it would not need to be
            explicitly stored.}

        \item the \index{routine signature}{\emph{routine signature}}
          is (when the routine address is non-nil) describing the
          signature of the routine address above.
      \end{enumerate}

      Notice that routine address and signature can only change when
      a new module~\footnote{The generated C code of modules also
        contains an array of constant objids, ana another array of
        routine objids.} is loaded (or at initial persistent state load
      time), and that can happen only when the agenda is
      inactive. Conceptually they are mostly constant (and do not
      require any locking).
        
      Most (in 2018, all) routines have the same C signature
      \texttt{objrout\_sigBM} corresponding to the predefined object
      \texttt{\emph{function\_sig}}. For an object of objid
      \texttt{\emph{oid}} of that signature its routine address
      corresponds to the C name \texttt{crout\emph{oid}\_BM}. For
      instance, to initialize (at load time) the object of oid
      \texttt{\_9CG8SKNs6Ql\_4PiHd8cnydn} the initial loader (or the
      module loader) would \texttt{dlsym} the
      \texttt{crout\_09Hug4WGnPK\_7PpZby8pz84\_BM} C function name.


      \item objects may also have some (nearly arbitrary)
        \index{payload}{\textbf{payload}}. That is a pointer (possibly
        nil) to some client data owned by the object; the payload is
        usually not a value but something else. The garbage collector
        should know all the payload types. In 2018 the following payloads are possible:

        \begin{enumerate}
        \item mutable \index{vector}{\emph{vector}} of values (like for components)
        \item mutable \index{associative table}{\emph{associative
            table}} associating objects to non-nil values (like for
          attributes)
          \item mutable \index{hash set}{\emph{hash set}} of objects.
        \end{enumerate}
\end{itemize}
