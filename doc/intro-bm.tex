% file intro-bm.tex, which is \input from bismon-doc.tex
\section{Introduction}


\subsection{Expected audience}

The reader of this document is expected to:
\begin{itemize}

  \item be fluent in C (cf. \cite{Kernighan:1988:CPL}) and/or C++
    (\cite{Stroustrup:2014:CplusPlus}) programming (notably on Linux
    and/or for embedded products, perhaps for IoT),

  \item be knowing a bit the \index{C11}{C11} standard
    (cf. \cite{C11:std,Memarian:2016:PLDI}) and/or the
    \index{C++11}{C++11} one (\cite{CplusPlus11:std}) and
    understanding well the notion of \index{undefined
      behavior}{\emph{undefined behavior}} \footnote{See
      \bmurl{http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html}
      and \bmurl{https://blog.regehr.org/archives/1520}} in C or C++
    programs,

  \item be a daily advanced user of \index{Linux}{Linux} for software
    development activities using GCC and related developer tools
    (e.g. \textit{binutils}, \texttt{git}, \texttt{make} or
    \texttt{ninja}, source code editor like \texttt{emacs} or
    \texttt{vim}, the {\LaTeX} text formatter\footnote{See
      \bmurl{https://www.latex-project.org/}. Some knowledge of
            {\LaTeX} is useful to improve or contribute to this
            document.}) on the \emph{command line}.


\item to be capable of building large free software projects (such as
  the GCC compiler (cf \cite{gcc-internals} \footnote{See
    \bmurl{http://gcc.gnu.org}}), the Linux kernel, the Qt toolkit and
  other open source projects of perhaps millions of source code lines)
  and smaller ones (e.g. \texttt{libonion} \footnote{see
    \bmurl{https://coralbits.com/libonion/}}) from their \emph{source}
  form.

\item have successfully downloaded and built the \emph{Bismon
  monitor} from its source code on
  \bmurl{https://github.com/bstarynk/bismon}, on his Linux workstation.
  
\item have contributed or participated to some free software or
  open source projects and understanding their social and economical
  (cf \cite{Weber:2004:SuccessOpenSource, Tirole:2016:EcoBienCommun,
    Nagle:2018:Contributing}) implications, the practical work flow,
  the importance of developer communities.
  
\item be interested in static source code analysis, so have
  already tried some such tools like \emph{Frama-C} \footnote{See
    \bmurl{http://frama-c.com/}} (cf. \cite{Cuoq:2012:Frama-C}), \emph{Clang
    analyzer} \footnote{See \bmurl{https://clang-analyzer.llvm.org/}},
  ..., and be aware of compiler concepts and technologies (read \cite{Aho:2006:DragonBook}).

\item be familiar with operating systems principles
  (see \cite{Tanenbaum:92:OS,ArpaciDusseau14-Book}) and well
  versed in Linux programming
  (cf. \cite{Mitchell:2001:ALP,Kerrisk:2010:LinuxProgramming} \footnote{look
    into \texttt{man} pages on
    \bmurl{http://man7.org/linux/man-pages/}}).

  \item be interested in various programming languages
    (cf. \cite{Abelson1996:SICP,Scott:2007:PLP,Queinnec:1996:LSP}),
    including domain specific ones.

\end{itemize}


To build this document (both in PDF and HTML forms) : build
\emph{bismon} \footnote{See the \emph{Readme} on
  \bmurl{https://github.com/bstarynk/bismon/} for building
  instructions} on your Linux workstatation, then run \texttt{make
  doc} (that uses {\LaTeX} and
\href{http://hevea.inria.fr/}{\emph{HeVeA}}).

Feedback and improvements on this document can be suggested by email
(to \bmemail{basile@starynkevitch.net} or
\bmemail{basile.starynkevitch@cea.fr}) or by submitting patches to
\textit{Bismon} thru its \bmurl{https://github.com/bstarynk/bismon} repository
(or by email). Notice that this document may contain generated
documentation, and will contain more and more generated parts in the
future.

The numerous footnotes in this report are for a second reading (and may
be used for forward references).

\subsection{About \textit{Bismon}}

\textit{Bismon} (a \emph{temporary name}) \footnote{\texttt{bismon} is a \textbf{temporary name}
  and could be changed, once we find a better name for it} is a free
software (GPLv3+ licensed)\footnote{The source code is unreleased but available, and continuously evolving, on \bmurl{https://github.com/bstarynk/bismon}} static source code whole-program analysis framework whose
initial domain will be \emph{Internet of Things} (or
\index{IoT}{IoT})\footnote{IoT is viewed as the first application
  domain of \textit{Bismon}, but it is hoped that most of
  \textit{Bismon} could be reused and later extended for other
  domains}. It is designed to work with the \textit{Gcc} compiler (see
\bmurl{gcc.gnu.org}) on a Linux workstation\footnote{Linux specific features are needed by \textit{Bismon}, which is unlikely to be buildable or run under other operating systems. My Linux distribution is \emph{Debian/Unstable}}. \textit{Bismon} is the
successor of \textit{GCC MELT} \footnote{The \textit{GCC MELT} web
  pages used to be on \texttt{gcc-melt.org} -a DNS domain relinquished
  in april 2018- and are archived on
  \bmurl{https://starynkevitch.net/Basile/gcc-melt}} (see \cite{Starynkevitch2007Multistage, starynkevitch-DSL2011}).

{\large \textit{Bismon} is \textbf{work in progress}}, and many things
described here are not (fully, or even partly!) implemented in 2018 or
could drastically change later. In particular, \textit{Bismon} is not
yet usable as a static source code analyser in mid-2018 (since work on
the infrastructure is not complete).

\bigskip

\subsection{Lessons learned from \textit{GCC MELT}}

@@ To be written

\medskip

\subsection{Driving principles for  \textit{Bismon}}

\textit{Bismon} is (like \textit{GCC MELT} was) a \textbf{domain
  specific language} implementation, targetted to ease static source
code analysis (above the \textit{GCC} compiler), with the following
features:

\begin{itemize}

  \item \index{persistency}{\textbf{persistency}}, somehow
    \textit{orthogonal persistency}. It is needed in particular
    because compiling some software project (analyzed by
    \textit{Bismon}) is a long-lasting procedure involving
    \textit{several} compiling and linking processes and commands. So
    most of the data handled by \textit{Bismon} can be persisted on
    disk, and reloaded at the next run. However, some data is
    temporary by nature\footnote{E.g. data related to a web session,
      or to a web HTTP exchange, or to an ongoing \texttt{gcc}
      compilation process, etc... needs not to be persisted, and would
      be useless when restarting the \textit{Bismon monitor}.} and
    should not be persisted. Such data is called temporary or
    \index{transient}{\textbf{transient}}. But the usual approach is
    to run the \textit{Bismon} program from some initial loaded state
    and have it \index{dump}{\textbf{dump}} its memory state on disk
    before exiting (and reload that augmented state at the next run),
    and probably more often than that (e.g. twice an hour, or even
    every five minutes).

  \item \textbf{dynamic typing}, like many scripting languages (such
    as Guile, Python, Lua, etc). Of course the dynamically typed data
    inside the \textit{Bismon monitor} is \index{garbage
      collection}{\textbf{garbage collected}}
    (cf. \cite{Jones:2011:GC-handbook})
    \footnote{\label{fn:initial-gc}The initial GC of the monitor is a crude precise garbage
      collector, but multi-thread compatible; it uses a naive
      stop-the-world mark\&sweep algorithm. Improving that GC is a
      difficult work, and past experience on \emph{GCC MELT} taught us
      that developing and debugging a GC is hard, and is a good
      illustration of Hofstadter's law (See
      \cite{Hofstadter:1979:GEB}). We might consider later using MPS
      from \bmurl{https://www.ravenbrook.com/project/mps/} but doing
      that could require recoding or regenerating a lot of code.}

  \item \textbf{homoiconicity} and \textbf{reflection} with
    \textbf{introspection} (cf \cite{Pitrat:1996:FGCS,
      Pitrat:1990:Metaconnaissances, Pitrat:2009:AST,
      Pitrat:2009:ArtifBeings}): all the DSL code is explicitly
    represented as data which can be processed by \textit{Bismon}, and
    the current state is accessible by the DSL.

    \item \textbf{translated} to \emph{C} code; and \textbf{generated}
      \emph{JavaScript} + \emph{HTML} in the \index{browser}{browser}, and generated
      \emph{C++} code of \emph{GCC} plugins

    \item \textbf{bootstrapped implementation}: ideally, all of
      \textit{Bismon} code (including C code dealing with data
      representations, persistent store, etc...) should be
      generated. However, this ideal has not yet be attained, and
      there is still some hand-written C code. It is hoped that most
      of the hand-written C code will become replaced by generated C
      code.
    \item ability to \textbf{generate GCC plugins}: the C++ code of
      GCC plugins performing static analysis of a single translation
      unit should be generated.

    \item with \textbf{collaborative web interface}, used by a
      \emph{small} team of \emph{trusted and well-behaving}
      developers~\footnote{The initial \texttt{bismon} implementation
        had a hand-coded crude GTK interface, nearly unusable. That
        interface is temporarily used to fill the persistent store
        till the web interface (generated by \emph{Bismon}) is
        usable. The GTK interface is already obsolete and should
        disappear at end of 2018. The Web interface (work in
        progress!) is mostly generated - all the HTML and JavaScript
        code is generated (or taken from outside existing projects
        e.g. \href{http://jquery.com/}{\emph{JQuery}} or
        \href{http://codemirror.net/}{\emph{CodeMirror}}), and their
        HTML and JavaScript generators are made of generated C
        code.}. The users of \emph{bismon} are expected to trust each
      other, and to use the \texttt{bismon} tool
      responsibly\footnote{For example, each \emph{bismon} user has
        the technical ability to erase most of the data inside
        \textit{Bismon monitor}, but is expected to not do so. There
        is no mechanism to forbid or warn him doing such bad things.}
      (likewise, developers accessing a \texttt{git} version control
      repository are supposed to act responsibly even if they are
      technically capable of removing most of the source code and its
      history stored in that repository). So protection against
      malicious behavior of \texttt{bismon} users is out of scope.

      Since \textit{Bismon} should be usable by a small team of
      developers (perhaps two or a dozen of them)\footnote{So
        \textit{Bismon}, considered as a Web application, would have
        at most a dozen of \index{browser}{browsers} -and associated users- accessing
        it. Hence, scalability to many HTTP connections is not at all
        a concern (in contrast with most usual web applications).}, it
      is handling some \index{personal data}{personal data} (relevant
      to \index{GDPR}{GDPR}), such as the first and last names (or
      pseudos) of users and their email and maintain a password file
      (used in the Web \index{login}{login} form). Compliance to
      regulations (e.g. European GDPR) is out of scope and should be
      in charge of the entities and/or persons using and/or deploying
      \textit{Bismon}. The login form template \footnote{on
        \bmurl{https://github.com/bstarynk/bismon/blob/master/login\_ONIONBM.thtml}}
      could be adapted on each deployment site.
\end{itemize}

Notice that \textit{Bismon} is \textbf{provided as free software}
(unreleased in 2018, but available on
\bmurl{github.com/bstarynk/bismon} ...) in \emph{source form only} and
should be \textbf{usable} (only) \textbf{on a Linux/x86-64
  workstation}... (typically, at least 32 gigabytes of RAM and
preferably more, at least 8 cores, several hundreds gigabytes of disk
or SSD).

The \textit{Bismon} system contains \textbf{persistent data} (which is
part of the system itself and should not be considered as ``external''
data; each team using \textit{Bismon} would run its own customized
version of their \textit{Bismon monitor}.), and should be
\textbf{regularily backed up}, and preferably version controlled at
the user site. It is strongly recommended to use
\index{git}{\texttt{git}} \footnote{See \bmurl{http://git-scm.com/}}
or perhaps some other distributed \index{version control}{version
  control} system, to \texttt{git commit} its files several times a
day (probably hourly or even more frequently, as often as a developer
is committing his C++ code), and to backup the files on some external
media or server at least daily. How that is done is outside of the
scope of this document. The \emph{dump facilities} inside
\textit{Bismon} are expected to be used quite often (as often as you
would save your report in a word processor, or your source file in a
source code editor), probably several times per hour. So a developer
team using \textit{Bismon} would probably \texttt{git clone} either
\texttt{git@github.com:bstarynk/bismon.git} thru SSH or
\bmurl{https://github.com/bstarynk/bismon.git}, build it (after
downloading and building required dependencies), and work on that
\texttt{git} repository (and of course back-up it quite often).


\medskip
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Multi-threaded and distributed aspects of \textit{Bismon}}

The \textit{Bismon monitor} is by itself a multi-threaded
process\footnote{In contrast of most scripting languages
  implementations such as Python, Ocaml, Ruby, etc..., we try hard to
  avoid any ``global interpreter lock'' and strive to develop a
  genuinely multi-threaded monitor.}.
It uses a \emph{fixed} {\index{thread pool}{\emph{thread pool}}} of
{\index{worker thread}{\emph{worker threads}}} (often active)
\footnote{The number of worker threads is given by the \texttt{--job}
  program argument to \texttt{bismon}. For an 8-cores workstation, it
  is suggested to set it to 5 or 6. It should be at least 2, and at
  most 15. This number of jobs also limits the set of simultaneously
  running external processes, such as \texttt{gcc} processes started
  by \emph{Bismon}.}, and additional (generally idle) threads for web
support and other facilities. The \textit{Bismon monitor} is
occasionally starting some external processes, in particular for the
compilation of generated \emph{GCC} plugins, and for the compilation
into \index{module}{\emph{module}s} -technically ``plugins''- of
dynamically generated \emph{C} code by \textit{Bismon}; later it will
dynamically load (with \texttt{dlopen}) these modules, and thus
\textit{Bismon} can increase its code (but cannot decrease it, even if
some code becomes unused and unreachable); however such modules are
\emph{never} \index{garbage collection}{garbage collected} (so
\texttt{dlclose} is never called). So in practice, it is recommended
to restart \emph{Bismon} every day (to avoid endless growth of its
code segments).


The worker threads of \emph{Bismon} are implementing its
\index{agenda}{\textbf{agenda}} \footnote{Details about the agenda are
  subject to change.} machinery. Conceptually, the agenda is a 5-tuple
of first-in first-out queues of \index{tasklet}{\textbf{tasklets}},
each such FIFO queue is corresponding to one of the five
\index{priority}{priorities} : \emph{very high}, \emph{high},
\emph{normal}, \emph{low}, \emph{very low}. Each agenda worker thread
removes one tasklet (chossing the queue of highest possible priority
which is non empty, and picking the tasklet in front of that queue)
and runs that tasklet quickly. A tasklet should run during a few
milliseconds (e.g. with some implicit kind of non-preemptive
scheduling) at most (so cannot do any blocking IO; so input and output
happens outside of the agenda). It may add one or more tasklets
(including itself) to the agenda (either at the front, or at the end,
of a queue of given priority), and it may remove existing tasklets
from the agenda. Of course tasklets run in parallel since there are
several worker threads to run the agenda. The agenda itself is not
persisted as a whole, but tasklets\footnote{Actually tasklets are
  objects (see §\ref{subsubsec:objects} page
  \pageref{subsubsec:objects} below), and to run them, the agenda is
  sending them a message with the predefined selector
  \texttt{\emph{run\_tasklet}}.}  themselves may be
\index{persistent}{persistent} or \index{transient}{transient}.
Tasklets can also be created outside of the agenda (e.g. by incoming
HTTP requests, by completion of external processes, by timers, ...)
and added asynchronously into the agenda.

Outside of the agenda, there is an \emph{idle queue} of delayed todo
closures (a queue of closures to be run, as if it was an idle priority
queue) with some arguments to apply to them. But that \index{idle
  queue}{idle queue} don't contain directly any tasklets. That idle
queue can be filled by external events~\footnote{For example, when an
  external compilation process completes, that queue is filled with
  some closure -provided when starting that compilation- and, as
  arguments, an object with a string buffer containing the output of
  that process, and the integer status of that process.}. Of course the idle
queue is not persisted.

\bigskip

When running (in 2019) for static source code analysis purposes, the \emph{Bismon system} involves several processes:

\begin{itemize}
\item the \emph{Bismon monitor} itself, with several threads (notably for the agenda mechanism described above)
  
  \item the web \index{browser}{browsers} of developers using that
    particular \emph{Bismon monitor}; each developer probably runs
    his/her own browser. That web browser is expected to follow latest
    Web technologies and standards (HTML5, Javascript6 i.e. EcmaScript
    2016 at least, WebSockets, ...). It should probably be a Firefox
    or a Chrome browser from 2017 or after. The HTML and Javascript is
    dynamically generated by the \emph{Bismon monitor} and should
    provide (to the developer using \emph{Bismon}) some ``single-page
    application'' feeling.

  \item sometimes \emph{Bismon} would generate some
    \texttt{modules/*.c} file during execution, and fork a (direct)
    compilation of it (technically forking a
    \texttt{./build-bismon-persistent-module.sh} -for persistent
    modules- or a \texttt{./build-bismon-temporary-module.sh} -for
    temporary modules- shell script, which invokes \texttt{make} which
    runs some \texttt{gcc} copmmand) into a ``plugin'' module
    \texttt{modubin/*.so}, which would be \texttt{dlopen}-ed.

  \item \emph{Bismon} should also generate the C++ code of \emph{GCC
    plugins}, to be later compiled then used (with \texttt{gcc} or
    \texttt{g++} option \texttt{-fplugin}). Two kinds of \emph{GCC}
    plugins are considered to be generated:

    \begin{enumerate}
      \item usually, the GCC plugin would be generated to assist
        [cross-] compilation (e.g. of IoT software) by developers
        using \emph{Bismon}. So for an IoT developer targetting some
        RaspberryPi, it could be a GCC plugin targetting the
        \texttt{arm-linux-gnueabi-gcc-8} cross-compiler (but the C++
        code of that plugin needs to be compiled by the native
        \texttt{gcc} on the host system).
        
      \item But the GCC API is so complex (and under-documented) that
        it is worth extracting it automatically by sometimes
        generating a GCC plugin to inspect the public headers of
        GCC\footnote{In \emph{GCC MELT}, we tried to describe by
          hand-coded \emph{MELT} code a small part of that GCC API and
          its glue for \emph{MELT}. This approach is exhausting, and
          makes following the evolution of GCC very difficult and
          time-consuming, since new \emph{MELT} code should be written
          or manually adapted at each release of \emph{GCC}. Some
          partial automation is needed to ease that effort of adapting
          to successive \emph{GCC} versions and their non-compatible
          plugins API}. Even when the end-user developer is targetting
        a small IoT chip requiring a cross-compiler (like
        \texttt{arm-linux-gnueabi-gcc-8} above), these GCC inspecting
        plugins are for the native \texttt{gcc} (both
        \cite{Schafmeister:2016:CANDO} and
        \cite{Schafmeister:2015:CLASP} are inspirational for such an
        approach).
        
    \end{enumerate}

    It is yet unclear how such generated C++ code for GCC plugins is
    actually compiled and when exactly is it executed. We might
    generate (at least for the first common case of GCC plugins
    generated for developers using \emph{Bismon}) \texttt{*.shar}
    archives (obtained by Web requests, or perhaps some \texttt{wget}
    or \texttt{curl} command in some \texttt{Makefile}) for
    \emph{GNU sharutils}\footnote{See
      \bmurl{https://www.gnu.org/software/sharutils/}}. containing the
    C++ code and also the \texttt{g++} command compiling it. The rare
    second case (GCC plugin code generated to inspect the GCC API)
    could be handled thru external processes (similar to compilation
    of \emph{Bismon} modules).
    
\end{itemize}

In principle, the various facets of \emph{Bismon} can run on different
machines as \index{distributed computing}{distributed computing}
(obviously the web browser is not required to run on the same machine
as the \emph{Bismon monitor}, but even the various compilations -of
code generated by \emph{Bismon}, and the cross-compilation of IoT
code- could happen on other machines).

Conceptually, we aim for a \index{multi-tier
  programming}{\textbf{multi-tier programming}} approach (inspired by
Ocsigen~\footnote{See \bmurl{https://ocsigen.org/}} with the high-level
DSL inside \emph{Bismon} generating code: in the \emph{Bismon
  monitor}, as modules; in the \emph{web browser}, as generated
Javascript and HTML; in the \emph{GCC} compiler, as generated GCC plugins.
