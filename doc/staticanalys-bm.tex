% file staticanalys-bm.tex, which is \input from bismon-chariot-doc.tex
\section{Static analysis of source code in \emph{Bismon}}
\label{sec:staticanalys}

Static analysis involves a \emph{generated} GCC plugin (whose C++ code
is generated by the \emph{bismon} persistent monitor) which
communicates with the monitor and sends to it some digested form of
the analyzed C or C++ code. Some translation-unit specific processing
can happen in that GCC plugin, but the whole program aspects of the
static code analysis should obviously be done inside the monitor, and
requires -and justifies- its persistence. The complexity and
non-stability of \emph{GCC} internal representations justify some
semi-automatic approach in extracting them (see §\ref{subsec:analygcc}
below).

The rest of this chapter will be written in the final D1.3\textsuperscript{v2} version.

A significant part of this chapter should be generated (like \emph{GCC
  MELT} generated its documentation, see
\cite{Starynkevitch-GCCMELTweb}) from the persistent state of
\emph{Bismon}. Perhaps this chapter should be put after the ``using
Bismon'' chapter (§\ref{sec:using}).

\subsection{static analysis of \emph{GCC} code}
\label{subsec:analygcc}

The \emph{GCC} compiler has a complex (and ill-defined,
under-documented and evolving, so unstable) application programming
interface (API) which can be used by plugins. So \emph{Bismon} needs
to analyze the various \emph{GCC} plugin related \emph{header files}
to extract important information about that API, so to be later able
to generate \emph{GCC} plugin code. Such an extraction (inspired by
the approach inside \emph{Clasp}, which does similar things with the
help of \emph{Clang}, see \cite{Schafmeister:2015:CLASP} for details)
needs not to care about the \emph{Gimple} instructions, but only about
the abstract syntax tree in \emph{Tree} and \emph{Generic} forms (see
\cite{gcc-internals} §11) to retrieve the full description of
\emph{GCC}.

This approach of extracting semi-automatically~\footnote{We are well
  aware that some work still needs to be done manually, in particular
  giving the really useful subpart of the \emph{GCC} API.} the GCC API
(of parsing GCC header files with some simple GCC plugin) is motivated
by past GCC MELT experience (where every feature of the GCC API had to
be \emph{explicitly} and manually described in MELT language; these
descriptions took a lot of time to be written and had to be manually
maintained; however, most of them could in theory be extracted
automatically from GCC headers).

A bootstrapping and incremental approach, in several ``steps'', is
worthwhile (and possible because of persistence): we will first
extract some very simple information from GCC header files, and use
them to improve the next extraction from the same GCC header
files. The \emph{slow} evolution~\footnote{GCC internals are
  \emph{slowly} evolving, because GCC itself is huge: its
  ``navigation'' is as slow as that of a supertanker which needs hours
  to turn and change directions. So for \emph{social} reasons the GCC
  community is changing the API slowly, but there is no promise of
  stability.}  of GCC API is practically relevant (most of the API of
\texttt{gcc-8.3} should stay in the next \texttt{gcc-9.0} version).

Descriptive data related to the API of a particular version of GCC
will thus stay persistently in the \emph{Bismon} monitor, but should
be updated at each release of \emph{GCC}. We care mostly about API
related to optimization passes, \emph{GENERIC}, \emph{Gimple},
\emph{SSA} and \emph{Optimized-Gimple}. We probably don't need to go
at the \emph{RTL} level.

Additional content of this §\ref{subsec:analygcc} will be written for the final D1.3\textsuperscript{v2}.

\subsection{static analysis of IoT firmware or application code}
\label{subsec:analysiot}

Once the API of the current version of \emph{GCC} is known to the
persistent monitor, we can generate the C++ code of \emph{GCC} plugins
for cross-compilers used by IoT developers.

A first static analysis, useful to IoT developers, will be related to
whole-program detection of \emph{stack overflow} \index{stack
  overflow}. By the way, such an analysis is currently not doable by
\emph{Frama-C}, because it don't know the size of each call
frame. However, \emph{GCC} is already computing that size (see the
\texttt{-fstack-usage} option which dumps the size of the call frame
of each function, and the \texttt{-Wframe-larger-than=\emph{bytesize}}
option), and we simply need to extract and keep it. We also need to
get a good approximation of the \emph{control flow graph\index{control
    flow graph}}. For that we need to extract basic blocks and just
\texttt{GIMPLE\_CALL} \emph{Gimple} statements (ignoring other kinds
of \emph{Gimple} statements). Of course, indirect calls (thru function
pointers, which are infrequently used in most IoT code) are harder to
handle (and could require interaction with the IoT developer using our
monitor, to annotate them).


We probably would also take as an example the analysis of some
\href{http://mqtt.org/}{MQTT library}. The insight is to trust some
existing MQTT implementation~\footnote{Our purpose is not to prove the
  correctness of a given MQTT implementation, which would require a
  formal methods approach à la \textsc{Vessedia}, but to help the
  developer using and trusting it, by checking some specific coding
  rules.}, and to help \emph{junior} developers in using it, by
checking simple coding rules relevant to MQTT.


Additional content of this §\ref{subsec:analysiot} will be written for the final D1.3\textsuperscript{v2}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Local Variables: ;;
%% compile-command: "cd ..; ./build-bismon-doc.sh" ;;
%% End: ;;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
