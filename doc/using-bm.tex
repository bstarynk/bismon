% file using-bm.tex, which is \input from bismon-chariot-doc.tex
\section{Using \emph{Bismon}}
\label{sec:using}

This section §\ref{sec:using} should become somehow a user manual, and
will be written for the final D1.3\textsuperscript{v2}. It is both for
the ordinary IoT developer just using \emph{bismon} for static
analysis of IoT source code, and for the static analysis expert
configuring and programming it.

Most of that should be generated from data persisted inside \emph{bismon}. Perhaps
should be exchanged with the ``static analysis'' chapter
(§\ref{sec:staticanalys}).

%\bigskip

%Notice that most of \emph{GCC MELT} documentation was generated. See its
%{\small\bmurl{http://starynkevitch.net/Basile/gcc-melt/meltpluginapi.html/meltpluginapi.html}}. Likewise,
%most of this chapter will be machine generated from the persistent
%state of \emph{Bismon}


\subsection{Web interface internal design}
\label{subsec:webinterf}

The Web interface \index{web interface} of \emph{bismon} is supposed
to be used without malice (see
§\ref{subsubsec:leveraging-static-analysis} and
§\ref{subsubsec:about-bismon}), with a recent graphical web browser
using HTTP/1.1. In particular, \emph{bismon} does not take any measure
against denial-of-service attacks. The network administrator running
\emph{bismon} is expected to deploy usual relevant techniques
(firewalls, \texttt{iptables}, HTTP proxying, DMZ, etc ...) to avoid
them. The browsers instances interacting with \emph{bismon} are few
(only a dozen of people in some IoT development team, and each uses
his/her graphical browser - a \emph{recent} Firefox or
Chrome~\footnote{So no particular effort is even taken to support a
  variety of old browsers: we don't have any code to e.g. support
  Internet Explorer pecularities or deficiencies.}). They are
physically and geographically located on the same local area network
as the machine running the \emph{bismon} monitor. So, from web
technologies perspective, \emph{bismon} is making different
trade-offs~\footnote{For example, we could accept making some HTTP
  exchange - e.g. with AJAX - on \emph{every} keystroke on the
  keyboard, but such practice won't be acceptable in usual web
  services. Also, we don't care much about minimizing the HTTP
  exchanges - no ``minification'' needed in practice!} than
``traditional'' web servers or web applications.

Each HTTP request \index{request} \index{web request} either
corresponds to a ``static'' file path under \texttt{webroot/} (for a
\texttt{GET} or \texttt{HEAD} HTTP request) or else it is handled
dynamically. For a static file path, that file is served directly by
\texttt{onion\_handler\_export\_local\_new} with a
\texttt{Content-Type} corresponding to its suffix; for example an HTTP
\texttt{GET} request of \texttt{favicon.ico} is answered with the
content of \texttt{webroot/favicon.ico} file, and an HTTP \texttt{GET}
request of \texttt{jscript/jquery.js} is served by the content of
\texttt{webroot/jscript/favicon.ico}. Care is taken~\footnote{In
  particular, any HTTP request containing \texttt{..} is rejected.} to
avoid serving any static file outside of \texttt{webroot/}. So the
\texttt{webroot/} directory contains static content such as images,
external JavaScript libraries, CSS stylesheets, etc... Static content
requests are always handled the same, so they work even without any
cookies. \index{request!static} \index{static request}

Any HTTP request which cannot be handled as a static resource like
above is considered as a request for dynamic content and is called a
\emph{dynamic request} \index{request!dynamic} \index{dynamic
  request}. Dynamic content requires a web session \index{web session}
\index{session!web session} cookie \index{web cookie} \index{cookie}
named \texttt{BISMONCOOKIE} which contains a cryptographic quality
hash (in practice unforgeable) and mentions the objid \index{objid}
(cf §\ref{subsubsec:objects}) of some web session object. If there is
no cookie \index{cookie}, or if the cookie is invalid or wrong
(e.g. forged), a login \index{login} form is returned. So any HTTP
request for a dynamic content (that is which is not handled as a
static resource like above) is rejected (with HTTP status \texttt{403
  Forbidden})) if the user (a \index{contributor} contributor in
\emph{bismon} parlance, cf. §\ref{subsubsec:bismon-evolving}) is not
logged in.

Dynamic requests are reified as very temporary \emph{bismon} objects
(cf. §\ref{subsubsec:objects}) of class
\texttt{webexchange\_object}. Their payload contains not only a string
buffer, to be filled with the HTTP response content, but also mentions
the web request (as processed by \texttt{libonion}) and the web
session object computed from the \texttt{BISMONCOOKIE} and may contain
some arbitrary data value. That web session object is created at web
login time and is of class \texttt{websession\_object}. It knows the
contributor who is logged in, the expiration time of the session, some
session data (an arbitrary \emph{bismon} value), and the web socket
\index{web socket} connection (if any) to the browser using that
session. An inactive web session expires in about an
hour~\footnote{See the \texttt{USER\_WEBSESSION\_EXPIRATION\_DELAY}
  constant in \texttt{web\_ONIONBM.c}}.

Of course, web request objects or web session objects are
\index{transient} transient and are not and should not be persisted at
dump time. So after each restart of the \emph{bismon} monitor, its web
users should login \index {login} again.

A dynamic request is handled by some closure \index{closure} and
should be answered in a couple~\footnote{See the
  \texttt{WEBEXCHANGE\_DELAY\_BM} constant in file
  \texttt{web\_ONIONBM.c} ...} of seconds; otherwise a \index{web
  timeout} web timeout \index{timeout!web} occurs. That closure is
executed (in the thread dealing with the HTTP request) and usually
would add some \index{tasklet} tasklet into the \index{agenda}
agenda. Most of the time, a fraction of second later, some other
tasklet would complete the filling the web request object, then an
HTTP reply is sent back to the browser. If a timeout occurs, an HTTP
\texttt{500 Internal Server Error} is given back to the browser and
the web request object is cleared.

The mapping between URL paths and closures handling dynamic requests
for them is given by the \texttt{webdict\_root} predefined object. The
\texttt{the\_web\_sessions} predefined object stores the dictionnary
of transient session objects and associates a cookie string to its
session object.

In practice, dynamic requests are usually generating the HTML5
\index{HTML5} content very dynamically. For generated HTML, it is
easier to use XHTML5 \index{XHTML5}, the XML variant \index{XML} of
HTML5, because its textual syntax is~\footnote{For instance, within a
  \texttt{<script} HTML5 element containing JavaScript, it is not even
  allowed in HTML5 to have \texttt{if (x \&lt; 5)} even if ordinary
  HTML rules suggest to use \texttt{\&lt;} instead of \texttt{<} in
  textual content... That makes compositional generation of mixture of
  HTML and JavaScript emitting HTML much harder.} much more regular
and easier to generate.
