% file using-bm.tex, which is \input from bismon-chariot-doc.tex
\section{Using \emph{Bismon}}
\label{sec:using}

This section §\ref{sec:using} should become somehow a user manual, and
will be written for the final D1.3\textsuperscript{v2}. It is both for
the ordinary IoT developer just using \emph{bismon} for static
analysis of IoT source code, and for the static analysis expert
configuring and programming it.

Most of that should be generated from data persisted inside \emph{bismon}. Perhaps
should be exchanged with the ``static analysis'' chapter
(§\ref{sec:staticanalys}).

%\bigskip

%Notice that most of \emph{GCC MELT} documentation was generated. See its
%{\small\bmurl{http://starynkevitch.net/Basile/gcc-melt/meltpluginapi.html/meltpluginapi.html}}. Likewise,
%most of this chapter will be machine generated from the persistent
%state of \emph{Bismon}


\subsection{Web interface internal design}
\label{subsec:webinterf}

The Web interface \index{web interface} of \emph{bismon} is supposed
to be used without malice (see
§\ref{subsubsec:leveraging-static-analysis} and
§\ref{subsubsec:about-bismon}), with a recent graphical web browser
using HTTP/1.1. In particular, \emph{bismon} does not take any measure
against \index{denial-of-service} denial-of-service attacks, since it
is supposed to be used on a trusted and friendly corporate intranet or
local area network, not directly on the wild Internet. The network
administrator running \emph{bismon} could deploy usual relevant
techniques (firewalls, \texttt{iptables}, HTTP proxying, DMZ, etc ...)
to avoid such attacks. The browsers instances interacting with
\emph{bismon} are few (only a dozen of people in some IoT development
team, and each uses his/her graphical browser - a \emph{recent}
Firefox or Chrome~\footnote{So no particular effort is even taken to
  support a variety of old browsers: we don't have any code to
  e.g. support Internet Explorer pecularities or deficiencies.}). They
are physically and geographically located on the same local area
network as the machine running the \emph{bismon} monitor. So, from web
technologies perspective, \emph{bismon} is making different
trade-offs~\footnote{For example, we could accept making some HTTP
  exchange - e.g. with AJAX - on \emph{every} keystroke on the
  keyboard, but such practice won't be acceptable in usual web
  services. Also, we don't care much about minimizing the HTTP
  exchanges - no ``minification'' needed in practice!} than
``traditional'' web servers or web applications : the web browser
$\leftrightarrow$ \emph{bismon} web server round-trip transmission
time is supposed to be very small so frequent AJAX requests are
possible, the bandwidth is expected to be quite large so voluminous
HTTP responses are acceptable, the number of simultaneous web
connections or of web sessions is tiny. Therefore most web
optimizations are practically unneeded.

Each HTTP request \index{request} \index{web request} either
corresponds to a ``static'' file path under \texttt{webroot/} (for a
\texttt{GET} or \texttt{HEAD} HTTP request) or else it is handled
dynamically. For a static file path, that file is served directly by
\texttt{onion\_handler\_export\_local\_new} with a
\texttt{Content-Type} corresponding to its suffix; for example an HTTP
\texttt{GET} request of \texttt{favicon.ico} is answered with the
content of \texttt{webroot/favicon.ico} file, and an HTTP \texttt{GET}
request of \texttt{jscript/jquery.js} is served by the content of
\texttt{webroot/jscript/jscript.js}. Care is taken~\footnote{In
  particular, any HTTP request containing \texttt{..} is rejected.} to
avoid serving any static file outside of \texttt{webroot/}. So the
\texttt{webroot/} directory contains static content such as images,
external JavaScript libraries, CSS stylesheets, etc... Static content
requests are always handled the same, so they work even without any
cookies. \index{request!static} \index{static request}

Any HTTP request which cannot be handled as a static resource like
above, because it has no corresponding file under \texttt{webroot/},
is considered as a request for dynamic content and is called a
\index{request!dynamic} \index{dynamic request} \emph{dynamic
  request}. Dynamic content requires a web session \index{web session}
\index{session!web session} cookie \index{web cookie} \index{cookie}
named \texttt{BISMONCOOKIE} which contains~\footnote{A practical
  example of \texttt{BISMONCOOKIE} value might be
  \texttt{n000041R970099188t330716425o\_6IHYL1fOROi\_58xJPnBLCTe}: 41
  is the serial number counting web sessions in the running
  \emph{bismon} process, 970099188 and 330716425 are two random
  numbers, \texttt{\_6IHYL1fOROi\_58xJPnBLCTe} is the
  randomly-generated objid of the web session object.} a cryptographic
quality hash (in practice unforgeable) and mentions the objid
\index{objid} (cf §\ref{subsubsec:objects}) of some web session
object. If there is no cookie, or if the \index{cookie} cookie is
invalid or wrong (e.g. forged), a login \index{login} form is
returned. So any HTTP request for a dynamic content (that is which is
not handled as a static resource like above) is rejected (with HTTP
status \texttt{403 Forbidden}) if the user (a \index{contributor}
contributor in \emph{bismon} parlance,
cf. §\ref{subsubsec:bismon-evolving}) is not logged in.

Dynamic requests are reified as very temporary \emph{bismon} objects
of class \texttt{webexchange\_object}. Their \emph{web exchange}
payload contains not only a string buffer~\footnote{Since a string
  buffer should contain valid UTF-8 string content without nul bytes,
  this restriction forbids binary contents in HTTP replies to dynamic
  requests. Hence, dynamically computed image contents are not
  possible, unless they use a textual format like SVG.}, to be filled
with the HTTP response content, but also mentions the web request (as
processed by \texttt{libonion}) and the web session object computed
from the \texttt{BISMONCOOKIE} and may contain some arbitrary data
value. The web exchange object is supposed to be filled -like string
buffers are- and at last given some integer HTTP status and
immediately sent back to the browser.  Their web session object is
created at web login time and is of class
\texttt{websession\_object}. It knows the contributor who is logged
in, the expiration time of the session, some session data (an
arbitrary \emph{bismon} value), and the web socket \index{web socket}
connection (if any) to the browser using that session. An inactive web
session expires in about an hour~\footnote{See the
  \texttt{USER\_WEBSESSION\_EXPIRATION\_DELAY} constant in
  \texttt{web\_ONIONBM.c}}.

Of course, web request objects or web session objects are
\index{transient} transient and are not and should not be persisted at
dump \index{dump} time (cf. §\ref{subsec:persistence}). So after each
restart of the \emph{bismon} monitor, its web users
(i.e. contributors) should login \index{login} again.

A dynamic request is handled by some closure \index{closure} and
should be answered in a couple~\footnote{See the
  \texttt{WEBEXCHANGE\_DELAY\_BM} constant in file
  \texttt{web\_ONIONBM.c} ...} of seconds; otherwise a \index{web
  timeout} web timeout \index{timeout!web} occurs. That web handler
\index{web handler} closure is applied to the remaining URL path
string and to the web exchange object created in the
\texttt{libonion}-specific thread dealing with the HTTP request, so
outside of the agenda machinery (cf §\ref{subsec:multithreadist}), and
usually would add some \index{tasklet} tasklet into the \index{agenda}
agenda. Most of the time, a fraction of a second later, some other
tasklet would complete the filling the web request object and give
some HTTP status code such as \texttt{200 OK}, then an HTTP reply is
sent back to the browser. If a timeout occurs because the web request
object has not been taken care of quickly enough, an HTTP \texttt{500
  Internal Server Error} is given back to the browser and that web
request object is cleared.

The mapping between URL paths (or prefixes) and web handler closures
handling dynamic requests for them is given by the
\texttt{webdict\_root}~\footnote{For example: an URL like
  \texttt{http://localhost:8086/show/status} is handled by some
  \emph{bismon} monitor listening HTTP requests on port 8086 and with
  \texttt{webdict\_root} associating the string \texttt{"show"} to
  some closure $\kappa$, that web handler closure $\kappa$ would be
  applied to the suffix string \texttt{"status"} and to the web
  exchange object $\omega$ created for that HTTP request. The result
  of that application is ignored, only side effects -often adding some
  tasklets into the agenda, and/or filling the web exchange object
  with some XHTML5, etc...- are useful.}  predefined object. If no web
handler closure is found, an \texttt{404 Not found} status is
returned. The \texttt{the\_web\_sessions} predefined object stores the
dictionnary of transient web session objects and associates a cookie
string to its web session object. That dictionnary is forcibly cleared
at start of the web server inside \emph{bismon}, but it should be
loaded empty, since web session objects are created and should remain
transient.

In practice, dynamic requests are usually generating the HTML5
\index{HTML5} content very dynamically. For generated HTML, it is much
easier to produce \index{XHTML5} XHTML5, the XML variant \index{XML}
of HTML5, because its textual syntax is~\footnote{For instance, within
  a \texttt{<script} HTML5 element containing JavaScript, it is not
  even allowed in HTML5 to have \texttt{if (x \&lt; 5)} even if
  ordinary HTML rules suggest to use \texttt{\&lt;} instead of
  \texttt{<} in textual content... That makes compositional generation
  of mixture of HTML and JavaScript emitting HTML much harder.} much
more regular and easier to generate than with plain HTML5.

The \texttt{webxhtml\_module} \index{module!\texttt{webxhtml\_module}}
in \emph{bismon} has code to ease the emission of XHTML5. And XHTML5
fragments are emitted by the \texttt{emit\_xhtml} routine
object~\footnote{So that \texttt{emit\_xhtml} is, like PHP, a
  machinery to emit arbitrary XHTML. However, we want to avoid
  thinking -like PHP was originally designed- in terms of emitting a
  stream of characters, and \texttt{emit\_xhtml} is supposed to emit
  structured XHTML from some structured, tree-like, internal
  representation. That internal representation is a DAG (directed
  acyclic graph).}. That \texttt{emit\_xhtml}, which get as arguments:
the value \texttt{v\_html} to emit; an arbitrary web context object
\texttt{o\_emitctx} which might be in simple cases just some web
session object; a string buffer object \texttt{o\_strbuf} which is
often the web exchange object; the tagged integer recursion depth
\texttt{v\_depth}, which is in general \emph{not}~\footnote{In very
  simple cases, without closures or sequences in the DAG of emitted
  values, the depth could be the depth of XHTML elements, so could be
  the indentation. In general, it is not.} the emitted
  indentation. When the string buffer is too full or the recursion
  depth is too deep, that \texttt{emit\_xhtml} fails. When the emitted
  HTML-reifying value \texttt{v\_html} is nil, nothing happens. When
  it is a scalar, it is emitted trivially: a string is emitted
  HTML-encoded (so \texttt{\&lt;} for \texttt{<}, etc...); a tagged
  integer is emitted in decimal notation; When \texttt{v\_html} is an
  object $\omega_{html}$, it is emitted per the following rules:

\begin{itemize}
\item the \texttt{newline} object emits an indented newline.
\item the \texttt{nlsp} object emits a newline when the current line is long enough, or else a space.
\item the \texttt{space} object emits a space character.
\item instances of \texttt{html\_void\_element\_object} emit some void
  element like e.g. \texttt{<hr class='foo'/>} using the
  \texttt{€\_0FRLxSGQlZ} routine. The \texttt{emit\_xhtml\_open}
  selector should emit -as a side effect- the opening tag \texttt{<hr
    class='foo'} without the ending \texttt{/>}.
\item instances of \texttt{html\_element\_object} emit recursively
  using \texttt{€\_5NH940lCHYJ} some nested XHTML element starting
  with a start tag like \texttt{<div} but ending with an end tag like
  \texttt{</div>}; the components of that objects are emitted
  recursively (with an incremented recursion depth). The spacing style
  is first determined by sending \texttt{html\_spacing} with the
  \texttt{o\_emitctx} and the depth. It can be \texttt{newline} for
  indented, newline separated, content; or \texttt{nlsp} for space or
  newline separated, unindented content; or \texttt{space} for space
  separated content; any other spacing style -notably nil- don't emit
  any separators in the content.
\item instances of \texttt{html\_sequence\_object} emit
      recursively their components but without surrounding tags.
\item any other object is emitted by its name, if it has some, or by
  its objid. This is mostly intended to represent common repeated names or
  words by a single and shared object.
\end{itemize}

When  \texttt{v\_html} is a node of connective $\omega_{conn}$, it is emitted per the following rules:

\begin{itemize}

\item if $\omega_{conn}$ is one of \texttt{int}, \texttt{hexa},
  \texttt{octa} and \texttt{v\_html} is an unary node with a integer
  son $n$, that integer $n$ is emitted in decimal, hexadecimal, octal respectively.
  
\item {\color{red}{@@ to be completed a lot.}}
  
\end{itemize}


When \texttt{v\_html} is a closure, it is applied {\color{red}{@@ to
    be completed}} and the result of that application is recursively
emitted. When \texttt{v\_html} is a sequence (set or tuple), its
components are emitted recursively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Local Variables: ;;
%% compile-command: "cd ..; ./build-bismon-doc.sh" ;;
%% End: ;;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
